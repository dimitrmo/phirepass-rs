<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Phirepass Console</title>
        <link rel="stylesheet" href="/xterm.css" />
        <style>
            :root {
                color-scheme: dark;
                background: radial-gradient(
                    circle at 20% 20%,
                    #0b1224,
                    #050810 55%
                );
                color: #e5e7eb;
                font-family: "Inter", system-ui, -apple-system, "Segoe UI",
                    sans-serif;
            }

            body {
                margin: 0;
                min-height: 100vh;
                display: grid;
                place-items: center;
                padding: 24px;
            }

            main {
                width: 92vw;
                background: rgba(255, 255, 255, 0.02);
                border: 1px solid rgba(255, 255, 255, 0.08);
                border-radius: 18px;
                padding: 20px 20px 16px 20px;
                box-shadow: 0 20px 80px rgba(0, 0, 0, 0.45);
            }

            header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 12px;
                margin-bottom: 8px;
            }

            h1 {
                margin: 0;
                font-size: 20px;
                letter-spacing: 0.02em;
            }

            #status {
                display: inline-flex;
                align-items: center;
                gap: 10px;
                padding: 8px 12px;
                border-radius: 999px;
                background: rgba(59, 130, 246, 0.12);
                color: #bfdbfe;
                font-weight: 600;
                font-size: 14px;
            }

            #nodes {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
                gap: 12px;
                margin: 12px 0 8px 0;
            }

            .node-card {
                border: 1px solid rgba(255, 255, 255, 0.08);
                border-radius: 12px;
                padding: 12px;
                background: rgba(15, 23, 42, 0.5);
                cursor: pointer;
                transition: border-color 120ms ease, transform 120ms ease;
            }

            .node-card:hover {
                border-color: rgba(56, 189, 248, 0.6);
                transform: translateY(-1px);
            }

            .node-card.selected {
                border-color: rgba(34, 197, 94, 0.9);
                box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.4);
            }

            .node-name {
                font-weight: 700;
                font-size: 15px;
                margin-bottom: 6px;
            }

            .node-meta {
                color: #cbd5e1;
                font-size: 13px;
                line-height: 1.4;
            }

            #log {
                margin: 10px 0 12px 0;
                min-height: 40px;
                max-height: 120px;
                overflow-y: auto;
                padding: 10px 12px;
                border-radius: 12px;
                background: rgba(15, 23, 42, 0.8);
                border: 1px solid rgba(255, 255, 255, 0.06);
                font-family: "JetBrains Mono", "SFMono-Regular", Consolas,
                    monospace;
                font-size: 13px;
            }

            .log-line {
                margin: 2px 0;
                color: #cbd5e1;
            }

            #terminal {
                width: 100%;
                height: 520px;
                border-radius: 12px;
                border: 1px solid rgba(255, 255, 255, 0.08);
                overflow: hidden;
                background: #0b1021;
            }

            button {
                appearance: none;
                border: none;
                border-radius: 10px;
                padding: 6px 10px;
                font-weight: 700;
                font-size: 12px;
                color: #0b1021;
                background: linear-gradient(135deg, #38bdf8, #22d3ee);
                cursor: pointer;
                box-shadow: 0 8px 20px rgba(56, 189, 248, 0.2);
            }

            button:active {
                transform: translateY(1px);
            }
        </style>
    </head>
    <body>
        <main>
            <header>
                <div>
                    <h1>Phirepass Console</h1>
                    <div style="color: #94a3b8; font-size: 14px">
                        xterm.js websocket bridge to /web/ws
                    </div>
                </div>
                <div
                    style="display: inline-flex; align-items: center; gap: 8px"
                >
                    <div id="status">Idle</div>
                    <button id="connect" disabled>Connect</button>
                    <button id="fullscreen">Fullscreen</button>
                </div>
            </header>
            <div
                style="
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 6px;
                    gap: 12px;
                "
            >
                <div style="font-weight: 600; color: #cbd5e1">Nodes</div>
                <button id="refresh-nodes">Refresh</button>
            </div>
            <div id="nodes"></div>
            <div id="log" aria-live="polite"></div>
            <div id="terminal"></div>
        </main>
        <script src="/xterm.js"></script>
        <script src="/xterm-addon-fit.js"></script>
        <script>
            (() => {
                const Protocol = { Control: 0, SSH: 1 };
                const encoder = new TextEncoder();
                const decoder = new TextDecoder();
                const apiBase = `${window.location.protocol}//${window.location.hostname}:8080`;

                const statusEl = document.getElementById("status");
                const logEl = document.getElementById("log");
                const connectBtn = document.getElementById("connect");
                const terminalHost = document.getElementById("terminal");
                const nodesEl = document.getElementById("nodes");
                const refreshBtn = document.getElementById("refresh-nodes");
                const fullscreenBtn = document.getElementById("fullscreen");

                const term = new Terminal({
                    convertEol: true,
                    cursorBlink: true,
                    fontFamily:
                        '"Berkeley Mono", "Fira Code", "SFMono-Regular", Menlo, monospace',
                    fontSize: 14,
                    allowProposedApi: true, // needed for bracketed paste
                    rightClickSelectsWord: false,
                    bellStyle: "sound",
                    disableStdin: false,
                    windowsMode: false,
                    logLevel: "info",
                    theme: {
                        background: "#0b1021",
                        foreground: "#e2e8f0",
                        cursor: "#67e8f9",
                    },
                });
                const fitAddon = new FitAddon.FitAddon();
                term.loadAddon(fitAddon);
                term.open(terminalHost);
                fitAddon.fit();
                term.focus();
                term.pasteMode = "bracketed"; // enable bracketed paste sequences

                let socket = null;
                let heartbeatTimer = null;
                let selectedNodeId = null;
                let nodes = [];
                let credentialMode = null; // "username" | "password"
                let usernameBuffer = "";
                let passwordBuffer = "";
                let sessionUsername = "";
                let isIntentionallyClosed = false;

                const log = (text) => {
                    const line = document.createElement("div");
                    line.className = "log-line";
                    line.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
                    logEl.appendChild(line);
                    logEl.scrollTop = logEl.scrollHeight;
                };

                const setStatus = (text, variant = "info") => {
                    statusEl.textContent = text;
                    const colors = {
                        info: "rgba(59, 130, 246, 0.12)",
                        ok: "rgba(34, 197, 94, 0.18)",
                        warn: "rgba(234, 179, 8, 0.16)",
                        error: "rgba(239, 68, 68, 0.18)",
                    };
                    statusEl.style.background = colors[variant] || colors.info;
                };

                const formatNumber = (value, digits = 1) =>
                    Number.isFinite(value) ? value.toFixed(digits) : "n/a";

                const formatBytes = (bytes) => {
                    if (!Number.isFinite(bytes)) return "n/a";
                    const units = ["B", "KiB", "MiB", "GiB", "TiB"];
                    let size = bytes;
                    let unit = units.shift();
                    while (units.length && size >= 1024) {
                        size /= 1024;
                        unit = units.shift();
                    }
                    return `${size.toFixed(1)} ${unit}`;
                };

                const renderNodes = (list) => {
                    nodesEl.innerHTML = "";
                    if (!list.length) {
                        const empty = document.createElement("div");
                        empty.style.color = "#94a3b8";
                        empty.textContent = "No nodes connected.";
                        nodesEl.appendChild(empty);
                        return;
                    }

                    list.forEach((node) => {
                        const card = document.createElement("div");
                        card.className = "node-card";
                        card.dataset.nodeId = node.id;

                        const name = document.createElement("div");
                        name.className = "node-name";
                        name.textContent = node.id;
                        card.appendChild(name);

                        const meta = document.createElement("div");
                        meta.className = "node-meta";
                        const stats = node.stats || {};
                        meta.innerHTML = [
                            `ip: ${node.ip}`,
                            `uptime: ${formatNumber(
                                node.connected_for_secs / 60,
                                1
                            )} min`,
                            `last hb: ${formatNumber(
                                node.since_last_heartbeat_secs,
                                1
                            )}s`,
                            `cpu: ${formatNumber(stats.host_cpu, 1)}%`,
                            `mem: ${formatBytes(
                                stats.host_mem_used_bytes
                            )} / ${formatBytes(stats.host_mem_total_bytes)}`,
                        ]
                            .map((line) => `<div>${line}</div>`)
                            .join("");
                        card.appendChild(meta);

                        card.addEventListener("click", () => {
                            // Check if there's an active websocket connection
                            if (
                                socket &&
                                socket.readyState === WebSocket.OPEN
                            ) {
                                // Already connected, warn user
                                const confirmed = confirm(
                                    `You are currently connected to a node. Do you want to disconnect and switch to ${node.id}?`
                                );
                                if (!confirmed) {
                                    // User cancelled - do nothing
                                    return;
                                }
                            }

                            selectedNodeId = node.id;
                            Array.from(nodesEl.children).forEach((el) =>
                                el.classList.toggle(
                                    "selected",
                                    el.dataset.nodeId === node.id
                                )
                            );
                            log(`Selected node ${node.id}`);
                            connect();
                        });

                        nodesEl.appendChild(card);
                    });
                };

                const fetchNodes = async () => {
                    try {
                        const res = await fetch(`${apiBase}/api/nodes`);
                        if (!res.ok) {
                            throw new Error(`status ${res.status}`);
                        }
                        nodes = await res.json();
                        renderNodes(nodes);
                    } catch (err) {
                        log(`Failed to fetch nodes: ${err.message}`);
                    }
                };

                const encodeFrame = (protocol, payload) => {
                    const buffer = new ArrayBuffer(5 + payload.byteLength);
                    const view = new DataView(buffer);
                    view.setUint8(0, protocol);
                    view.setUint32(1, payload.byteLength, false);
                    const bytes = new Uint8Array(buffer);
                    bytes.set(new Uint8Array(payload), 5);
                    return bytes;
                };

                const decodeFrame = (data) => {
                    if (!(data instanceof ArrayBuffer) || data.byteLength < 5) {
                        return null;
                    }

                    const view = new DataView(data);
                    const protocol = view.getUint8(0);
                    const length = view.getUint32(1, false);
                    if (data.byteLength < 5 + length) {
                        return null;
                    }

                    const payload = new Uint8Array(data, 5, length);
                    return { protocol, payload };
                };

                const sendControl = (message) => {
                    if (!socket || socket.readyState !== WebSocket.OPEN) {
                        return;
                    }
                    const payload = encoder.encode(JSON.stringify(message));
                    socket.send(encodeFrame(Protocol.Control, payload));
                };

                const sendTunnelData = (bytes) => {
                    if (!socket || socket.readyState !== WebSocket.OPEN) {
                        log("Cannot send SSH data: socket not connected");
                        return;
                    }
                    if (!selectedNodeId) {
                        log("Cannot send SSH data: no node selected");
                        return;
                    }
                    sendControl({
                        type: "TunnelData",
                        protocol: Protocol.SSH,
                        target: selectedNodeId,
                        data: Array.from(bytes),
                    });
                };

                const sendResize = (cols, rows) => {
                    if (!socket || socket.readyState !== WebSocket.OPEN) {
                        return;
                    }
                    if (!selectedNodeId) {
                        return;
                    }
                    sendControl({
                        type: "Resize",
                        target: selectedNodeId,
                        cols,
                        rows,
                    });
                };

                const sendHeartbeat = () => sendControl({ type: "Heartbeat" });
                const requestSshTunnel = (target, username, password) =>
                    sendControl({
                        type: "OpenTunnel",
                        protocol: Protocol.SSH,
                        target,
                        username,
                        password,
                    });

                const resetCredentialCapture = () => {
                    credentialMode = null;
                    usernameBuffer = "";
                    passwordBuffer = "";
                };

                const promptForUsername = () => {
                    resetCredentialCapture();
                    sessionUsername = "";
                    term.reset();
                    term.write("Enter username: ");
                    credentialMode = "username";
                    setStatus("Username required", "warn");
                };

                const promptForPassword = (shouldReset = false) => {
                    if (shouldReset) {
                        term.reset();
                    } else {
                        term.writeln("");
                    }
                    passwordBuffer = "";
                    credentialMode = "password";
                    term.write("Enter password: ");
                    setStatus("Enter password", "warn");
                };

                const submitPassword = () => {
                    const password = passwordBuffer;
                    resetCredentialCapture();

                    if (!password.length) {
                        log("Password is required to start SSH session");
                        promptForPassword();
                        return;
                    }

                    if (!sessionUsername) {
                        log("Username is required before submitting password");
                        promptForUsername();
                        return;
                    }

                    setStatus("Authenticating...", "info");
                    log(
                        `Credentials submitted for user, attempting SSH connection...`
                    );
                    requestSshTunnel(selectedNodeId, sessionUsername, password);
                    sendResize(term.cols, term.rows);
                };

                const submitUsername = () => {
                    const username = usernameBuffer.trim();
                    if (!username.length) {
                        log("Username is required to start SSH session");
                        term.writeln("");
                        term.write("Enter username: ");
                        usernameBuffer = "";
                        return;
                    }

                    sessionUsername = username;
                    promptForPassword(true);
                };

                const cancelCredentialEntry = () => {
                    resetCredentialCapture();
                    log("Credential entry cancelled");
                    setStatus("Idle", "warn");
                    cleanup();
                };

                const handleUsernameKeystroke = (data) => {
                    if (data === "\r" || data === "\n") {
                        term.write("\r\n");
                        submitUsername();
                        return;
                    }

                    if (data === "\u0003") {
                        term.write("^C\r\n");
                        cancelCredentialEntry();
                        return;
                    }

                    if (data === "\u007f") {
                        if (usernameBuffer.length) {
                            usernameBuffer = usernameBuffer.slice(0, -1);
                            term.write("\b \b");
                        }
                        return;
                    }

                    if (data >= " " && data <= "~") {
                        usernameBuffer += data;
                        term.write(data);
                    }
                };

                const handlePasswordKeystroke = (data) => {
                    // Enter submits the captured password.
                    if (data === "\r" || data === "\n") {
                        term.write("\r\n");
                        submitPassword();
                        return;
                    }

                    // Ctrl+C cancels capture and disconnects.
                    if (data === "\u0003") {
                        term.write("^C\r\n");
                        cancelCredentialEntry();
                        return;
                    }

                    // Handle backspace - no visual feedback to hide password length.
                    if (data === "\u007f") {
                        if (passwordBuffer.length) {
                            passwordBuffer = passwordBuffer.slice(0, -1);
                        }
                        return;
                    }

                    // Accept only printable characters - silently capture without visual feedback.
                    if (data >= " " && data <= "~") {
                        passwordBuffer += data;
                    }
                };

                const cleanup = () => {
                    if (heartbeatTimer) {
                        clearInterval(heartbeatTimer);
                        heartbeatTimer = null;
                    }

                    if (socket) {
                        isIntentionallyClosed = true;
                        socket.close();
                        socket = null;
                    }

                    resetCredentialCapture();
                    sessionUsername = "";
                    fitAddon.fit();
                };

                const connect = () => {
                    if (!selectedNodeId) {
                        log("Select a node before connecting");
                        return;
                    }

                    cleanup();
                    term.reset();
                    fitAddon.fit();
                    setStatus("Connecting...");

                    const scheme =
                        window.location.protocol === "https:" ? "wss" : "ws";
                    const url = `${scheme}://${window.location.hostname}:8080/api/web/ws`;

                    log(`Connecting to ${url}`);
                    socket = new WebSocket(url);
                    socket.binaryType = "arraybuffer";

                    socket.onopen = () => {
                        log("WebSocket connected");
                        setStatus("Connecting to node...", "info");
                        sendHeartbeat();
                        heartbeatTimer = setInterval(sendHeartbeat, 15_000);
                        // Send OpenTunnel without credentials initially
                        requestSshTunnel(
                            selectedNodeId,
                            sessionUsername || null,
                            null
                        );
                    };

                    socket.onmessage = (event) => {
                        if (typeof event.data === "string") {
                            log(
                                `Received text frame (${event.data.length} bytes)`
                            );
                            return;
                        }

                        const frame = decodeFrame(event.data);
                        if (!frame) {
                            log("Dropped malformed frame");
                            return;
                        }

                        if (frame.protocol === Protocol.SSH) {
                            term.write(new Uint8Array(frame.payload));
                        } else if (frame.protocol === Protocol.Control) {
                            try {
                                const msg = JSON.parse(
                                    decoder.decode(frame.payload)
                                );

                                if (msg.type === "TunnelClosed") {
                                    const protocolName =
                                        msg.protocol === Protocol.SSH
                                            ? "SSH"
                                            : msg.protocol === Protocol.Control
                                            ? "Control"
                                            : `Protocol ${
                                                  msg.protocol ?? "unknown"
                                              }`;
                                    log(
                                        `${protocolName} tunnel closed by remote host`
                                    );
                                    setStatus("Tunnel closed", "warn");
                                    term.reset();
                                    cleanup();
                                } else if (msg.type === "Error") {
                                    log(
                                        `Control: ${msg.type ?? "unknown"} - ${
                                            msg.message ?? "no message"
                                        }`
                                    );

                                    const errorKind = msg.kind || 0;
                                    const RequiresPassword = 100;
                                    const RequiresUsernamePassword = 110;

                                    if (
                                        errorKind === RequiresUsernamePassword
                                    ) {
                                        term.reset();
                                        setStatus(
                                            "Credentials required",
                                            "warn"
                                        );
                                        log(
                                            "SSH username and password are required."
                                        );
                                        promptForUsername();
                                    } else if (errorKind === RequiresPassword) {
                                        term.reset();
                                        setStatus("Password required", "warn");
                                        log("SSH password is required.");
                                        if (!sessionUsername) {
                                            promptForUsername();
                                        } else {
                                            promptForPassword();
                                        }
                                    } else {
                                        term.reset();
                                        const message =
                                            msg.message ||
                                            "SSH authentication failed. Please try again.";
                                        setStatus("Auth failed", "error");
                                        log(message);
                                        sessionUsername = "";
                                        promptForUsername();
                                    }
                                } else {
                                    log(`Control: ${msg.type ?? "unknown"}`);
                                }
                            } catch (err) {
                                log(`Control parse error: ${err.message}`);
                            }
                        }
                    };

                    socket.onclose = (evt) => {
                        // Only log and cleanup if this was not an intentional close
                        if (!isIntentionallyClosed) {
                            setStatus("Disconnected", "warn");
                            const reason = evt.reason || `code ${evt.code}`;
                            log(`Socket closed (${reason})`);
                            cleanup();
                        } else {
                            // Log intentional closure
                            log("WebSocket connection closed");
                        }
                        isIntentionallyClosed = false;
                    };

                    socket.onerror = (err) => {
                        setStatus("Error", "error");
                        log(`Socket error: ${err.message ?? "unknown error"}`);
                    };
                };

                term.onData((data) => {
                    if (credentialMode === "username") {
                        handleUsernameKeystroke(data);
                        return;
                    }

                    if (credentialMode === "password") {
                        handlePasswordKeystroke(data);
                        return;
                    }
                    sendTunnelData(encoder.encode(data));
                });

                term.onResize(({ cols, rows }) => {
                    sendResize(cols, rows);
                });

                const resizeObserver = new ResizeObserver(() => {
                    fitAddon.fit();
                    sendResize(term.cols, term.rows);
                });

                resizeObserver.observe(terminalHost);

                terminalHost.addEventListener("click", () => {
                    term.focus();
                });

                connectBtn.addEventListener("click", connect);
                refreshBtn.addEventListener("click", fetchNodes);

                fullscreenBtn.addEventListener("click", () => {
                    const container = document.documentElement;
                    if (!document.fullscreenElement) {
                        container.requestFullscreen().catch((err) => {
                            log(`Failed to enter fullscreen: ${err.message}`);
                        });
                    } else {
                        document.exitFullscreen().catch((err) => {
                            log(`Failed to exit fullscreen: ${err.message}`);
                        });
                    }
                });

                fetchNodes();
            })();
        </script>
    </body>
</html>
