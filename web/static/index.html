<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phirepass Console</title>
    <link rel="stylesheet" href="/xterm.css">
    <style>
        :root {
            color-scheme: dark;
            background: radial-gradient(circle at 20% 20%, #0b1224, #050810 55%);
            color: #e5e7eb;
            font-family: "Inter", system-ui, -apple-system, "Segoe UI", sans-serif;
        }

        body {
            margin: 0;
            min-height: 100vh;
            display: grid;
            place-items: center;
            padding: 24px;
        }

        main {
            width: 92vw;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 18px;
            padding: 20px 20px 16px 20px;
            box-shadow: 0 20px 80px rgba(0, 0, 0, 0.45);
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }

        h1 {
            margin: 0;
            font-size: 20px;
            letter-spacing: 0.02em;
        }

        #status {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            border-radius: 999px;
            background: rgba(59, 130, 246, 0.12);
            color: #bfdbfe;
            font-weight: 600;
            font-size: 14px;
        }

        #nodes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 12px;
            margin: 12px 0 8px 0;
        }

        .node-card {
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 12px;
            background: rgba(15, 23, 42, 0.5);
            cursor: pointer;
            transition: border-color 120ms ease, transform 120ms ease;
        }

        .node-card:hover {
            border-color: rgba(56, 189, 248, 0.6);
            transform: translateY(-1px);
        }

        .node-card.selected {
            border-color: rgba(34, 197, 94, 0.9);
            box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.4);
        }

        .node-name {
            font-weight: 700;
            font-size: 15px;
            margin-bottom: 6px;
        }

        .node-meta {
            color: #cbd5e1;
            font-size: 13px;
            line-height: 1.4;
        }

        #log {
            margin: 10px 0 12px 0;
            min-height: 40px;
            max-height: 120px;
            overflow-y: auto;
            padding: 10px 12px;
            border-radius: 12px;
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.06);
            font-family: "JetBrains Mono", "SFMono-Regular", Consolas, monospace;
            font-size: 13px;
        }

        .log-line {
            margin: 2px 0;
            color: #cbd5e1;
        }

        #terminal {
            width: 100%;
            height: 520px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            overflow: hidden;
            background: #0b1021;
        }

        button {
            appearance: none;
            border: none;
            border-radius: 10px;
            padding: 6px 10px;
            font-weight: 700;
            font-size: 12px;
            color: #0b1021;
            background: linear-gradient(135deg, #38bdf8, #22d3ee);
            cursor: pointer;
            box-shadow: 0 8px 20px rgba(56, 189, 248, 0.2);
        }

        button:active {
            transform: translateY(1px);
        }
    </style>
</head>
<body>
<main>
    <header>
        <div>
            <h1>Phirepass Console</h1>
            <div style="color: #94a3b8; font-size: 14px;">xterm.js websocket bridge to /web/ws</div>
        </div>
        <div style="display: inline-flex; align-items: center; gap: 8px;">
            <div id="status">Idle</div>
            <button id="connect" disabled>Connect</button>
            <button id="fullscreen">Fullscreen</button>
        </div>
    </header>
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; gap: 12px;">
        <div style="font-weight: 600; color: #cbd5e1;">Nodes</div>
        <button id="refresh-nodes">Refresh</button>
    </div>
    <div id="nodes"></div>
    <div id="log" aria-live="polite"></div>
    <div id="terminal"></div>
</main>
<script src="/xterm.js"></script>
<script src="/xterm-addon-fit.js"></script>
<script>
    (() => {
        const Protocol = { Control: 0, SSH: 1 };
        const encoder = new TextEncoder();
        const decoder = new TextDecoder();
        const apiBase = `${window.location.protocol}//${window.location.hostname}:3000`;

        const statusEl = document.getElementById("status");
        const logEl = document.getElementById("log");
        const connectBtn = document.getElementById("connect");
        const terminalHost = document.getElementById("terminal");
        const nodesEl = document.getElementById("nodes");
        const refreshBtn = document.getElementById("refresh-nodes");
        const fullscreenBtn = document.getElementById("fullscreen");

        const term = new Terminal({
            convertEol: true,
            cursorBlink: true,
            fontFamily: '"Berkeley Mono", "Fira Code", "SFMono-Regular", Menlo, monospace',
            fontSize: 14,
            allowProposedApi: true, // needed for bracketed paste
            rightClickSelectsWord: false,
            bellStyle: "sound",
            disableStdin: false,
            windowsMode: false,
            logLevel: "info",
            theme: {
                background: '#0b1021',
                foreground: '#e2e8f0',
                cursor: '#67e8f9',
            },
        });
        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);
        term.open(terminalHost);
        fitAddon.fit();
        term.focus();
        term.pasteMode = "bracketed"; // enable bracketed paste sequences

        let socket = null;
        let heartbeatTimer = null;
        let selectedNodeId = null;
        let nodes = [];
        let awaitingPassword = false;
        let passwordBuffer = "";

        const log = (text) => {
            const line = document.createElement("div");
            line.className = "log-line";
            line.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
            logEl.appendChild(line);
            logEl.scrollTop = logEl.scrollHeight;
        };

        const setStatus = (text, variant = "info") => {
            statusEl.textContent = text;
            const colors = {
                info: "rgba(59, 130, 246, 0.12)",
                ok: "rgba(34, 197, 94, 0.18)",
                warn: "rgba(234, 179, 8, 0.16)",
                error: "rgba(239, 68, 68, 0.18)",
            };
            statusEl.style.background = colors[variant] || colors.info;
        };

        const formatNumber = (value, digits = 1) =>
            Number.isFinite(value) ? value.toFixed(digits) : "n/a";

        const formatBytes = (bytes) => {
            if (!Number.isFinite(bytes)) return "n/a";
            const units = ["B", "KiB", "MiB", "GiB", "TiB"];
            let size = bytes;
            let unit = units.shift();
            while (units.length && size >= 1024) {
                size /= 1024;
                unit = units.shift();
            }
            return `${size.toFixed(1)} ${unit}`;
        };

        const renderNodes = (list) => {
            nodesEl.innerHTML = "";
            if (!list.length) {
                const empty = document.createElement("div");
                empty.style.color = "#94a3b8";
                empty.textContent = "No nodes connected.";
                nodesEl.appendChild(empty);
                return;
            }

            list.forEach((node) => {
                const card = document.createElement("div");
                card.className = "node-card";
                card.dataset.nodeId = node.id;

                const name = document.createElement("div");
                name.className = "node-name";
                name.textContent = node.id;
                card.appendChild(name);

                const meta = document.createElement("div");
                meta.className = "node-meta";
                const stats = node.stats || {};
                meta.innerHTML = [
                    `addr: ${node.addr}`,
                    `uptime: ${formatNumber(node.connected_for_secs / 60, 1)} min`,
                    `last hb: ${formatNumber(node.since_last_heartbeat_secs, 1)}s`,
                    `cpu: ${formatNumber(stats.host_cpu, 1)}%`,
                    `mem: ${formatBytes(stats.host_mem_used_bytes)} / ${formatBytes(stats.host_mem_total_bytes)}`,
                ]
                    .map((line) => `<div>${line}</div>`)
                    .join("");
                card.appendChild(meta);

                card.addEventListener("click", () => {
                    selectedNodeId = node.id;
                    Array.from(nodesEl.children).forEach((el) =>
                        el.classList.toggle("selected", el.dataset.nodeId === node.id)
                    );
                    log(`Selected node ${node.id}`);
                    connect();
                });

                nodesEl.appendChild(card);
            });
        };

        const fetchNodes = async () => {
            try {
                const res = await fetch(`${apiBase}/nodes`);
                if (!res.ok) {
                    throw new Error(`status ${res.status}`);
                }
                nodes = await res.json();
                renderNodes(nodes);
            } catch (err) {
                log(`Failed to fetch nodes: ${err.message}`);
            }
        };

        const encodeFrame = (protocol, payload) => {
            const buffer = new ArrayBuffer(5 + payload.byteLength);
            const view = new DataView(buffer);
            view.setUint8(0, protocol);
            view.setUint32(1, payload.byteLength, false);
            const bytes = new Uint8Array(buffer);
            bytes.set(new Uint8Array(payload), 5);
            return bytes;
        };

        const decodeFrame = (data) => {
            if (!(data instanceof ArrayBuffer) || data.byteLength < 5) {
                return null;
            }

            const view = new DataView(data);
            const protocol = view.getUint8(0);
            const length = view.getUint32(1, false);
            if (data.byteLength < 5 + length) {
                return null;
            }

            const payload = new Uint8Array(data, 5, length);
            return { protocol, payload };
        };

        const sendControl = (message) => {
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                return;
            }
            const payload = encoder.encode(JSON.stringify(message));
            socket.send(encodeFrame(Protocol.Control, payload));
        };

        const sendTunnelData = (bytes) => {
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                log("Cannot send SSH data: socket not connected");
                return;
            }
            if (!selectedNodeId) {
                log("Cannot send SSH data: no node selected");
                return;
            }
            sendControl({
                type: "TunnelData",
                protocol: Protocol.SSH,
                target: selectedNodeId,
                data: Array.from(bytes),
            });
        };

        const sendResize = (cols, rows) => {
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                return;
            }
            if (!selectedNodeId) {
                return;
            }
            sendControl({
                type: "Resize",
                target: selectedNodeId,
                cols,
                rows,
            });
        };

        const sendHeartbeat = () => sendControl({ type: "Heartbeat" });
        const requestSshTunnel = (target, password) =>
            sendControl({ type: "OpenTunnel", protocol: Protocol.SSH, target, password });

        const startPasswordCapture = () => {
            awaitingPassword = true;
            passwordBuffer = "";
            term.writeln("");
            term.write("Please enter your password: ");
            setStatus("Enter password", "warn");
        };

        const submitPassword = () => {
            const password = passwordBuffer;
            awaitingPassword = false;
            passwordBuffer = "";

            if (!password.length) {
                log("Password is required to start SSH session");
                startPasswordCapture();
                return;
            }

            setStatus("Connected", "ok");
            log("Password captured, starting SSH tunnel...");
            requestSshTunnel(selectedNodeId, password);
            sendResize(term.cols, term.rows);
        };

        const handlePasswordKeystroke = (data) => {
            // Enter submits the captured password.
            if (data === "\r" || data === "\n") {
                term.write("\r\n");
                submitPassword();
                return;
            }

            // Ctrl+C cancels capture and disconnects.
            if (data === "\u0003") {
                term.write("^C\r\n");
                awaitingPassword = false;
                passwordBuffer = "";
                log("Password entry cancelled");
                setStatus("Idle", "warn");
                cleanup();
                return;
            }

            // Handle backspace.
            if (data === "\u007f") {
                if (passwordBuffer.length) {
                    passwordBuffer = passwordBuffer.slice(0, -1);
                    term.write("\b \b");
                }
                return;
            }

            // Accept only printable characters and mask them.
            if (data >= " " && data <= "~") {
                passwordBuffer += data;
                term.write("*");
            }
        };

        const cleanup = () => {
            if (heartbeatTimer) {
                clearInterval(heartbeatTimer);
                heartbeatTimer = null;
            }

            if (socket) {
                socket.close();
                socket = null;
            }

            awaitingPassword = false;
            passwordBuffer = "";
            fitAddon.fit();
        };

        const connect = () => {
            if (!selectedNodeId) {
                log("Select a node before connecting");
                return;
            }

            cleanup();
            term.reset();
            fitAddon.fit();
            setStatus("Connecting...");

            const scheme = window.location.protocol === "https:" ? "wss" : "ws";
            const url = `${scheme}://${window.location.hostname}:3000/web/ws`;

            log(`Connecting to ${url}`);
            socket = new WebSocket(url);
            socket.binaryType = "arraybuffer";

            socket.onopen = () => {
                setStatus("Awaiting password", "warn");
                log("WebSocket connected");
                sendHeartbeat();
                heartbeatTimer = setInterval(sendHeartbeat, 15_000);
                startPasswordCapture();
            };

            socket.onmessage = (event) => {
                if (typeof event.data === "string") {
                    log(`Received text frame (${event.data.length} bytes)`);
                    return;
                }

                const frame = decodeFrame(event.data);
                if (!frame) {
                    log("Dropped malformed frame");
                    return;
                }

                if (frame.protocol === Protocol.SSH) {
                    term.write(new Uint8Array(frame.payload));
                } else if (frame.protocol === Protocol.Control) {
                    try {
                        const msg = JSON.parse(decoder.decode(frame.payload));
                        log(`Control: ${msg.type ?? "unknown"}`);
                        if (msg.type === "Error") {
                            term.reset();
                            const message =
                                msg.message || "SSH authentication failed. Please try again.";
                            setStatus("Auth failed", "error");
                            log(message);
                            startPasswordCapture();
                        }
                    } catch (err) {
                        log(`Control parse error: ${err.message}`);
                    }
                }
            };

            socket.onclose = (evt) => {
                setStatus("Disconnected", "warn");
                const reason = evt.reason || `code ${evt.code}`;
                log(`Socket closed (${reason})`);
                cleanup();
            };

            socket.onerror = (err) => {
                setStatus("Error", "error");
                log(`Socket error: ${err.message ?? "unknown error"}`);
            };
        };

        term.onData((data) => {
            if (awaitingPassword) {
                handlePasswordKeystroke(data);
                return;
            }
            sendTunnelData(encoder.encode(data));
        });

        term.onResize(({ cols, rows }) => {
            sendResize(cols, rows);
        });

        const resizeObserver = new ResizeObserver(() => {
            fitAddon.fit();
            sendResize(term.cols, term.rows);
        });

        resizeObserver.observe(terminalHost);

        connectBtn.addEventListener("click", connect);
        refreshBtn.addEventListener("click", fetchNodes);

        fullscreenBtn.addEventListener("click", () => {
            const container = document.documentElement;
            if (!document.fullscreenElement) {
                container.requestFullscreen().catch((err) => {
                    log(`Failed to enter fullscreen: ${err.message}`);
                });
            } else {
                document.exitFullscreen().catch((err) => {
                    log(`Failed to exit fullscreen: ${err.message}`);
                });
            }
        });

        fetchNodes();
    })();
</script>
</body>
</html>
