use crate::db::redis::MemoryDB;
use crate::env::Env;
use async_trait::async_trait;
use dashmap::DashMap;
use log::{debug, info, warn};
use phirepass_common::server::ServerIdentifier;
use pingora::prelude::*;
use pingora::proxy::{ProxyHttp, Session, http_proxy_service};
use std::sync::Arc;
use std::time::{Duration, Instant};

#[derive(Debug)]
struct CacheEntry {
    server: ServerIdentifier,
    cached_at: Instant,
}

struct WsProxy {
    upstream_servers: DashMap<String, CacheEntry>,
    memory_db: Arc<MemoryDB>,
}

struct RequestCtx {
    node_id: Option<String>,
    server_id: Option<String>,
}

/// Extracts the node ID and server ID from the `sec-websocket-protocol` header.
/// According to the project's WebSocket implementation, the node ID is expected to be the first protocol
/// and the server ID is expected to be the second protocol in the list.
fn extract_protocols(req: &RequestHeader) -> (Option<String>, Option<String>) {
    let protocols: Vec<String> = req
        .headers
        .get("sec-websocket-protocol")
        .and_then(|value| value.to_str().ok())
        .map(|value| {
            value
                .split(',')
                .map(|part| part.trim().to_string())
                .filter(|part| !part.is_empty())
                .collect()
        })
        .unwrap_or_default();

    let node_id = protocols.get(0).cloned();
    let server_id = protocols.get(1).cloned();

    (node_id, server_id)
}

impl WsProxy {
    fn get_server_by_node_id(
        &self,
        node_id: &str,
        server_id: Option<&str>,
    ) -> anyhow::Result<ServerIdentifier> {
        info!("searching for server by user node {}", node_id);

        let needs_refresh = if let Some(entry) = self.upstream_servers.get(node_id) {
            debug!("found server entry {:?}", entry);
            let expired = entry.cached_at.elapsed() >= Duration::from_secs(30);
            if !expired {
                debug!(
                    "server found in upstream cache: {} {:?}",
                    entry.server.id,
                    entry.cached_at.elapsed()
                );
                return Ok(entry.server.clone());
            }
            true
        } else {
            info!("server[id={}] not found in cache", node_id);
            false
        };

        if needs_refresh {
            self.upstream_servers.remove(node_id);
        }

        let server = self
            .memory_db
            .get_user_server_by_node_id(node_id, server_id)?;
        let server = ServerIdentifier::get_decoded(server)?;

        self.upstream_servers.insert(
            node_id.to_string(),
            CacheEntry {
                server: server.clone(),
                cached_at: Instant::now(),
            },
        );

        info!("server found: {}", server.id);

        Ok(server)
    }
}

#[async_trait]
impl ProxyHttp for WsProxy {
    type CTX = RequestCtx;

    fn new_ctx(&self) -> Self::CTX {
        RequestCtx {
            node_id: None,
            server_id: None,
        }
    }

    async fn upstream_peer(
        &self,
        _session: &mut Session,
        ctx: &mut Self::CTX,
    ) -> Result<Box<HttpPeer>> {
        let Some(node_id) = ctx.node_id.as_ref() else {
            warn!("node_id missing before upstream selection");
            return Err(Error::new(HTTPStatus(400)));
        };

        info!("proxying request for node_id {}", node_id);

        let server_with_node = match ctx.server_id {
            Some(ref server_id) => self.get_server_by_node_id(node_id, Some(server_id)),
            None => self.get_server_by_node_id(node_id, None),
        };

        let server = match server_with_node {
            Ok(server) => server,
            Err(err) => {
                warn!("node could not be found: {err}");
                return Err(Error::new(HTTPStatus(400)));
            }
        };

        info!("proxying request to server {}", server.id);

        let peer = HttpPeer::new((server.private_ip, server.port), false, server.fqdn);
        debug!("proxying request for peer {}", peer);

        Ok(Box::new(peer))
    }

    async fn request_filter(&self, session: &mut Session, ctx: &mut Self::CTX) -> Result<bool> {
        debug!("request_filter");

        let req = session.req_header();
        let (node_id, server_id) = extract_protocols(req);

        if node_id.is_none() {
            warn!("sec-websocket-protocol missing or empty");
            session.respond_error(400).await?;
            return Ok(true);
        }

        ctx.node_id = node_id;
        if let Some(node_id) = ctx.node_id.as_ref() {
            debug!("node id found: {}", node_id);
        }

        ctx.server_id = server_id;
        if let Some(server_id) = ctx.server_id.as_ref() {
            debug!("server id found: {}", server_id);
        }

        Ok(false)
    }
}

pub fn start(config: Env) -> anyhow::Result<()> {
    info!("running server on {} mode", config.mode);

    let memory_db = MemoryDB::create(&config)?;
    info!("connected to valkey");

    let bind_addr = format!("{}:{}", config.host, config.port);
    info!("running proxy on {}", bind_addr);

    let mut server = Server::new(None)?;
    server.bootstrap();

    let proxy = WsProxy {
        upstream_servers: DashMap::new(),
        memory_db: Arc::new(memory_db),
    };
    let mut service = http_proxy_service(&server.configuration, proxy);
    service.add_tcp(&bind_addr);
    info!("proxy prepared");

    server.add_service(service);
    info!("proxy running forever");

    server.run_forever();
}

#[cfg(test)]
mod tests {
    use super::*;
    use http::Method;
    use http::header::HeaderValue;

    #[test]
    fn extract_protocols_none_when_missing_header() {
        let req = RequestHeader::build(Method::GET, b"/", None).unwrap();
        let (node_id, server_id) = extract_protocols(&req);
        assert!(node_id.is_none());
        assert!(server_id.is_none());
    }

    #[test]
    fn extract_protocols_none_when_empty_header() {
        let mut req = RequestHeader::build(Method::GET, b"/", None).unwrap();
        req.headers
            .insert("sec-websocket-protocol", HeaderValue::from_static(""));
        let (node_id, server_id) = extract_protocols(&req);
        assert!(node_id.is_none());
        assert!(server_id.is_none());
    }

    #[test]
    fn extract_protocols_first_and_second_non_empty_tokens() {
        let mut req = RequestHeader::build(Method::GET, b"/", None).unwrap();
        req.headers.insert(
            "sec-websocket-protocol",
            HeaderValue::from_static(" , node-1 , server-1 , other"),
        );
        let (node_id, server_id) = extract_protocols(&req);
        assert_eq!(node_id, Some("node-1".to_string()));
        assert_eq!(server_id, Some("server-1".to_string()));
    }

    #[test]
    fn extract_protocols_with_multiple_protocols() {
        let mut req = RequestHeader::build(Method::GET, b"/", None).unwrap();
        req.headers.insert(
            "sec-websocket-protocol",
            HeaderValue::from_static("node-123,server-456"),
        );
        let (node_id, server_id) = extract_protocols(&req);
        assert_eq!(node_id, Some("node-123".to_string()));
        assert_eq!(server_id, Some("server-456".to_string()));
    }
}
